<?xml version="1.0" encoding="UTF-8"?>
<tei xmlns="http://www.tei-c.org/ns/1.0">
<teiHeader>
<fileDesc xml:id="_1"/>
<encodingDesc>
<appInfo>
<application version="0.8.0" ident="GROBID" when="2024-08-31T06:18+0000">
<ref target="https://github.com/kermitt2/grobid">A machine learning software for extracting information from scholarly documents</ref>
</application>
</appInfo>
</encodingDesc>
</teiHeader>
<text xml:lang="en">
<p>With increasing amounts of digitally available data from all over the world, manual annotation of cognates in multi-lingual word lists becomes more and more time-consuming in historical linguistics. Using available software packages to pre-process the data prior to manual analysis can drastically speed-up the process of cognate detection. Furthermore, it allows us to get a quick overview on data which have not yet been intensively studied by experts. <rs xml:id="12952088" type="software" subtype="component" corresp="12952089">LingPy</rs> is a <rs xml:id="12952089" type="software" subtype="environment">Python</rs> library which provides a large arsenal of routines for sequence comparison in historical linguistics. With <rs xml:id="12952090" type="software">LingPy</rs>, linguists can not only automatically search for cognates in lexical data, but they can also align the automatically identified words, and output them in various forms, which aim at facilitating manual inspection. In this tutorial, we will briefly introduce the basic concepts behind the algorithms employed by <rs xml:id="12952091" type="software">LingPy</rs> and then illustrate in concrete workflows how automatic sequence comparison can be applied to multi-lingual word lists. The goal is to provide the readers with all information they need to (1) carry out cognate detection and alignment analyses in <rs xml:id="12952092" type="software">LingPy</rs>, (2) select the appropriate algorithms for the appropriate task, (3) evaluate how well automatic cognate detection algorithms perform compared to experts, and (4) export their data into various formats useful for additional analyses or data sharing. While basic knowledge of the Python language is useful for all analyses, our tutorial is structured in such a way that scholars with basic knowledge of computing can follow through all steps as well.</p>
<p>Sequence comparison is one of the key tasks in historical linguistics. By comparing words or morphemes across languages, linguists can identify which words have sprung from a common source in genetically related languages, or which words have been borrowed from one language to another. By comparing words within a language, linguists can identify grammatical and lexical morphemes, cluster words into families, and shed light on the internal history of languages. So far the majority of this work has been carried out manually. Linguists sift through dictionaries and fieldwork notes, trying to identify those words which reflect a shared history across languages. All etymological dictionaries available today have been based on manual word comparison and their results fill thousands of pages. Even the largest databases which offer cognate judgments, such as the <rs xml:id="12952094" type="software">Austronesian Basic Vocabulary Database</rs> (<rs xml:id="12952095" type="software">ABVD</rs>, <rs xml:id="12952096" type="bibr">Greenhill et al., 2008</rs>) or the <rs xml:id="12952097" type="software">Indo-European Lexical Cognacy Database</rs> <rs xml:id="12952141" type="bibr">(Dunn, 2012)</rs> are based on manual assessments of cognacy.</p>
<p>With the increasing amounts of digitally available data it becomes harder for linguists to keep up. For example, the <rs xml:id="12952098" type="software">Sino-Tibetan Etymological and Thesaurus</rs> database <rs xml:id="12952142" type="bibr">(Matisoff, 2015)</rs>, contains more than 500,000 words, but only a small amount of words have been compared etymologically (see Hill and List, 2017: 64f). We need to take advantage of increasing amounts of data, refining work on well-established languages, and fostering work on the world's understudied languages. To do this, however, we will have to rethink the way we compare languages.</p>
<p>Historical linguists are skeptical about automating the methods for cognate identification (see Holman et al. (2011) and commentaries, as well as List et al. (2017b)). First, the accuracy of automated methods is often low, failing to reproduce the analyses of linguistic experts. Especially, the use of the edit distance (Levenshtein, 1965) has been criticized for being linguistically too nave, conflating sound correspondences and lexical replacement, to be useful for subgrouping or cognate detection (Campbell, 2011;Greenhill, 2011). Second, it is hard to verify many algorithms as they are seen as black-boxes which hide the crucial decisions leading to cognate judgments and subgroupings, making it difficult for scholars to determine whether similarities are due to inheritance or contact (Ja ¨ger, 2015;List et al., 2017b). The nontransparency of automatic methods is highly problematic for computational historical linguistics: if we do not know what evidence decisions are based on, we cannot criticize and improve them.</p>
<p>However, methods for automatic sequence comparison in historical linguistics have dramatically improved during the last two decades. Starting with the pioneering work on pairwise and multiple phonetic alignment (Kondrak, 2000;Proki c et al., 2009), new methods for phonetic alignment and automatic cognate detection solve both the problems of verification and accuracy (List et al., 2017b;Ja ¨ger et al., 2017). First, these algorithms are based on phonetically informed metrics on sound similarities. Importantly, any algorithmically identified correspondences are logged and can be inspected by researchers. Second, in a wide-ranging test of these methods, they have been found to be highly accurate and able to correctly identify cognates in almost 90% of the cases (List et al., 2017b).</p>
<p><rs xml:id="12952099" type="software">LingPy</rs> <rs xml:id="12952143" type="bibr">(List et al., 2017a)</rs> provides these algorithms as part of a stable open-source software package that works on all major platforms. Given the complexity of the problems involving sequence comparison in historical linguistics, computers will not be able to replace human judgments any time soon, but with the recent advancements, the methods are definitely good enough to provide substantial help for classical historical linguists to pre-analyze the data to be later corrected by experts, or to check the consistency of human cognate judgments. Over the long run, computational methods can also contribute to the bigger questions of language evolution, be it indirectly, by increasing the amount of digitally available high-quality annotated data, or directly, by providing scholars' access to data too large to be processed by humans alone.</p>
<p>In the following, we will give a concise overview on how automatic sequence comparison can be carried out. After discussing general aspects of sequence comparison (Section 2), we will introduce basic ideas on the data needed (Section 3). We will then turn to the core tasks of automatic sequence comparison, namely automatic phonetic alignment (Section 4) and automatic cognate detection (Section 5). We conclude by showing how automatic approaches for cognate detection can be evaluated (Section 6), and how results can be exported to various formats (Section 7).</p>
<p>This article is supplemented by a detailed interactive tutorial in form of an <rs xml:id="12952101" type="software">IPython Notebook</rs> <rs xml:id="12952144" type="bibr">(Pe ´rez and Granger, 2007)</rs> which illustrates how all methods discussed here can be practically applied (see the Supplementary material for more information). Having installed the necessary software (Tutorial: 1), readers can follow the tutorial step by step and investigate how the algorithms work in practise. Our data is based on a small sample of Polynesian languages taken from the <rs xml:id="12952102" type="software">ABVD</rs>, which we substantially revised, both with respect to the phonetic transcriptions and the expert cognate judgments. All data needed to replicate the analyses discussed here are supplemented. We give more information in the interactive tutorial (Tutorial: 2.1).</p>
<p>The words and morphemes which constitute a language are best modeled as sequences of sounds. Sequences have information content not only from their elements (segments, whether these are phonemes, graphemes, or morphemes) but also via the order of the elements, a consistent comparison of sequences should account for both order and content. Alignments are a very general way to model differences between sequences. The major idea is to arrange two or more sequences in a matrix in such a way that similar or identical segments which occur in similar positions are placed in the same column of the matrix. If segments are missing in one sequence where no counterpart for a segment can be found, this is represented by a gap character, usually the dash-symbol (List, 2014b).</p>
<p>Sequence alignments are crucial in biology, where they are used to compare protein and DNA sequences (Durbin et al., 2002). In historical linguistics, however, they are usually only implicitly employed, and initial attempts to arrange cognate words in a matrix go back to the early 20th century, as one can see from an early example based on Dixon and Kroeber (1919: 61) given in Fig. 1. The authors themselves describe this way of representing sequence similarities as a 'columnar form' with the goal to 'bring out parallelisms that otherwise might fail to impress without detailed analysis and discussion' (Dixon and Kroeber, 1919: 55). The figure further shows how the data would look if they were rendered in contemporary alignment editors for historical linguistics (List, 2017). Dixon and Kroeber's wording nicely expresses one of the major advantages of alignments: the transparency of homology assessments. Scholars often list long lists of cognate sets in the literature, claiming that all words are somehow related to each other, but if they do not list the alignments, it is often impossible, even for experts in the same language family, to understand where exactly the authors think that certain segments are similar.</p>
<p>Given that the inference of historically related words is not based on superficial word similarities but on recurrent systematic similarities, known as regular sound correspondences (Lass, 1997: 130), all judgments regarding the relatedness of words across languages directly rely on previously established sequence alignments (Fox, 1995: 67f). Alignment analyses not only increase the transparency of cognate judgments, but they also play a crucial role in substantiating these judgments in a first place. As can be seen from Table 1, similarities in cognate words in Sikaiana and Tahitian (data taken from Greenhill et al., 2008) are not based on the identity of sounds, but rather in the regularity of occurrence: whenever Sikaiana has a [k] and a [l], Tahitian has a [?] and a [r], respectively. Without alignments, we could not identify this similarity. Alignments are also at the core of all automatic sequence comparison approaches in historical linguistics, as we will see throughout this tutorial.</p>
<p>When searching for cognates across languages, we usually assume that our data are given in some kind of wordlist, a list in which a number of concepts is translated into various languages. How many concepts we select depends on the research question, and various concept lists and questionnaires, ranging from 40 (Brown et al., 2008) up to more than 1,000 concepts (Haspelmath and Tadmor, 2009) have been proposed so far (see the overview in List et al. (2016a)). Our data example for this tutorial is based on the questionnaire of the <rs xml:id="12952103" type="software">ABVD</rs> project <rs xml:id="12952146" type="bibr">(Greenhill et al., 2008)</rs>, consisting of 210 concepts, which were translated into 31 different Polynesian languages. For closely related languages, such as those in the Polynesian family, this gives us enough information to infer regular correspondences automatically, although it is clear that for analyses of Dixon and Kroeber, 1919), contrasted with a 'modern' representation using the <rs xml:id="12952104" type="software">EDICTOR</rs> tool <rs xml:id="12952145" type="bibr">(List, 2017)</rs>. more distant language relationship the number of words per language may not be enough. The basic format used by <rs xml:id="12952106" type="software">LingPy</rs> is a tab-separated input file in which the first row serves as a header and defines the content of the rest of the rows. The very first column is reserved for numerical identifiers (which all need to be unique), while the order of the other columns is arbitrary, with specific columns being required, and others being optional. Essential columns which always must be provided are the language name (DOCULECT), the comparison concept (CONCEPT), the original transcription (International Phonetic Alphabet (IPA), FORM, or VALUE), and a space-segmented form of the transcription (TOKENS). Multiple synonyms for the same comparison concept in the same language should be written in separate rows and given a separate ID each. The data in the TOKENS-column should supply the transcriptions in space-segmented form, that is, instead of transcribing the Fila word for 'all' as [eutSi], the software expects [e u tS i], which is internally interpreted as a sequence of five segments, namely [e], [u], [tS] and [i], with [tS] representing a voiceless post-alveolar affricate. If the TOKENS are not supplied to the algorithm, it will try to segment the data automatically, provided it can find the column IPA, which is otherwise not necessarily required to appear in the data. This however, may lead to various problems and unexpected behavior. We therefore urge all users of <rs xml:id="12952107" type="software">LingPy</rs> to make sure that they supply segmented data to the algorithm, making furthermore sure that they adhere to the general standards of transcription as they are represented in the IPA (IPA, 1999). 1 The format can be created manually by using either a text editor, or a spreadsheet program that allows to export to tab-separated format. To a large degree, this input format is compatible with the one advocated by the Cross-Linguistic Data Formats (CLDF) initiative (Forkel et al., 2017), the main difference being that <rs xml:id="12952108" type="software">LingPy</rs> requires a flat single file with tabstop as separators, while CLDF supports multiple files. CLDF furthermore encourages the use of reference catalogs, such as Glottolog (Hammarstro ¨m et al., 2017) or Concepticon (List et al., 2018), in order to increase the comparability of linguistic data across datasets, while <rs xml:id="12952109" type="software">LingPy</rs> is indifferent regarding the overall comparability as long as the data is internally consistent. As of version <rs xml:id="12952110" type="version" corresp="12952111">2.6</rs>, <rs xml:id="12952111" type="software">LingPy</rs> offers routines to convert to and from CLDF (see Tutorial: 6.3). Figure 2 provides a basic summary on <rs xml:id="12952112" type="software">LingPy</rs>'s input formats. More information on the format, and how it can be loaded into <rs xml:id="12952113" type="software">LingPy</rs> can be found in the supplemented interactive tutorial (Tutorial: 2.2-3).</p>
<p>Data quality and consistency plays a crucial role in the outcome of an automatic sequence comparison. As a general rule of thumb, we recommend all linguists who apply <rs xml:id="12952114" type="software">LingPy</rs> or other software to carry out automatic sequence comparison, to pay careful attention to what we call the SANE rules for data sanity: users should pay close attention to providing a sensible segmentation of their data, they should aim for high coverage, there should be no mixing of data from different sources (as this usually leads to inconsistent transcriptions and may also increase the number of synonyms), and synonyms should be evaded. 2 These rules are summarized in Table 2. If the original data does not provide reliable phonetic transcriptions, as it was the case with the Polynesian data we use in this tutorial, orthography profiles (Moran and Cysouw, 2017) provide an easy way to refine transcriptions while at the same time segmenting the data, and the <rs xml:id="12952115" type="software">EDICTOR</rs> tool <rs xml:id="12952147" type="bibr">(List, 2017)</rs> offers convenient ways to check phonological inventories of all varieties (Tutorial: 2.4). Various coverage statistics can be computed in <rs xml:id="12952117" type="software">LingPy</rs> (see Tutorial: 2.5). Synonym statistics can also be easily computed (see Tutorial: 2.6). Users should always keep in mind that the quality of automatic sequence comparison crucially depends on the quality of the data submitted to the algorithms.</p>
<p>Alignments are crucial for historical language comparison to search for regular sound correspondence patterns, layers of borrowed words, or even use them as the starting point for linguistic reconstruction (Fox, 1995). A further important advantage is that they can be easily quantified, as we will see in Section 5. Since phonetic alignment is heavily influenced by bioinformatics, linguists using phonetic alignments should have some basic understanding of original algorithms and terminology. In this context, it is not necessarily important to understand how the algorithms work in detail. Instead, we think it is more important to learn (also by testing the algorithms with different data and parameters) how the different options from which users can choose influence the results. In the following, we will quickly introduce basic algorithms and concepts involving alignments in historical linguistics, and how they relate to alignments in bioinformatics. We will follow the traditional division into pairwise and multiple alignments (which result from the differences in complexity of the algorithms), and introduce the most important concepts and parameters that users should know when applying the methods.</p>
<p>Pairwise alignment analyses in biology and computer science date back to the 1970s when scholars like Needleman and Wunsch (1970), and Wagner and Fischer (1974) proposed algorithms based on the dynamic programming paradigm (Eddy, 2004b) which drastically reduced the computation time for the task of aligning two sequences with each other. The basic idea of the algorithms by Needleman and Wunsch and Wager and Fischer was to split the problem of finding one optimal alignment between two sequences into subparts and building the general solution from optimal alignments of smaller subsequences (Durbin et al., 2002: 19). 3 The major parameters of pairwise alignment algorithms are the scoring function, the gap function, and the alignment mode. The scoring function (Fig. 3A, Tutorial: 3.1.1) determines how the matching of segments is penalized (or favored). In biology, it is well known that amino acid mutations follow certain transition preferences. The scoring function defines transition probabilities for each segment pair, and biologists make use of a large number of empirically derived scoring functions (Eddy, 2004a). In linguistics, on the other hand, we know well that certain sounds are more likely to occur in correspondence relations with each other (Dolgopolsky, 1964;Brown et al., 2013), and this knowledge can be used as a proxy when designing a scoring function in linguistics. While biology deals with Fila [e u tS i] 'all'</p>
<p>Aim for high coverage Each language should have about the same number of words recorded across the wordlist. A high mutual coverage is important to allow algorithms to find enough information to determine the major signal.</p>
<p>NOT:</p>
<p>No mixing of data from different sources Mixing data for the same language from various sources can lead to inconsistencies in the phonetic representation of words, even if they are all given in plain phonetic transcriptions. This will weaken the evidence for regular sound correspondences.</p>
<p>NOT:</p>
<p>Evade synonyms Languages often have multiple words for a given meaning. However, these can cause problems for sequence comparison and further downstream analyses like phylogenetic reconstruction. Having abundant synonyms in the data (e.g. 40 words for snow) will necessarily blur this signal.</p>
<p>NOT:</p>
<p>Tahitian 'sea' small alphabets, in linguistics, the numbers of possible sounds in the languages of the world amounts to the thousands (Moran et al., 2014). It is not practical to design a matrix containing and confronting all sounds with each other, and most algorithms reduce the size of the alphabet by lumping similar sounds into a set of predefined sound classes (Fig. 3B, Tutorial: 3.1.2), for which transition probabilities can be efficiently defined, and which are then given as input for the alignment algorithm (List, 2012a;Holman et al., 2008). The introduction of gaps in an alignment (Fig. 3C, Tutorial: 3.1.3) can be seen as a special case of a scoring function. Instead of comparing two segments, the algorithm checks whether the introduction of a gap might be preferable. While gaps were originally given the same penalty, independent of the element with which they were compared, later studies showed that they could even be individually adjusted for each position in a sequence (Thompson et al., 1994). In linguistics, we know that sounds in certain positions (like initial consonants) are less likely to be lost and that new sounds tend to appear in specific contexts as well. In <rs xml:id="12952118" type="software">LingPy</rs>, positionspecific gap penalties are derived from the prosodic profiles of sequences (List, 2012a). Prosodic profiles essentially reflect for each segment of a word whether it occurs in weak or strong prosodic positions, and the user-defined gap penalty is modified accordingly.</p>
<p>The alignment mode (Fig. 3D, Tutorial: 3.1.4) basically determines which parts of individual sequences are compared. It is often impossible to compare two words entirely. Instead, we compare only certain parts of which we know that they are cognate, ignoring parts of which we know they are not. Since the same problem occurs when comparing the genes of diverse species in bioinformatics, biologists have long since been working on solutions, reflected in local alignment analyses (Smith and Waterman, 1981) in which only the most similar parts of sequences are compared (see Fig. 3), while the rest is ignored, or semi-global alignments (Durbin et al., 2002: 26f).</p>
<p>What should users keep in mind when carrying out pairwise alignment analyses? As a rule of thumb, we recommend caution with local alignment analyses, since these can show unexpected behavior. We also recommend care with custom changes applied to the scoring or the gap function. Users often naively think by just 'telling' the computers which sound changes, this would automatically lead to excellent alignments and at times complain that <rs xml:id="12952148" type="software">LingPy</rs>'s standard algorithms fail to 'detect certain obvious changes'. However, alignments are no way to determine sound changes, they are at best a first step for linguistic reconstruction, and none of the algorithms which have been proposed so far models any kind of change. What is modeled instead are correspondences of sounds. It is difficult, if not impossible, to design an algorithm that aligns sequences of all kinds of diversity without proposing certain analyses which look awkward to a trained linguist. But remember, automatic sequence comparison is not there to replace the experts, but to help them.</p>
<p>Pairwise alignments are crucial for most automatic cognate detection methods (List, 2014b;Ja ¨ger et al., 2017). In order to visualize cognate judgments, or to reconstruct proto-forms, however, pairwise alignments are not of great help, as most linguistic research applies to at least three if not more language varieties. It may sound counterintuitive for readers not familiar with the major workflows for automatic cognate detection that pairwise alignments are mainly used to detect cognates across multiple languages, while multiple alignments are only later computed from existing cognate sets. Why not compute multiple alignments right from the beginning, as for example, proposed by Wheeler and Whiteley (2015)? The reason for this workflow is that alignments only make sense when representing cognate wordsaligning unrelated words just leads to chance similarities.</p>
<p>For reasons of algorithmic complexity, pairwise alignment algorithms cannot simply be rewritten to account for an arbitrary number of sequences. In order to address this problem, early approaches used heuristics that approximate optimal multiple alignments (Feng and Doolittle, 1987;Thompson et al., 1994). Most of these algorithms compute pairwise alignments in a first step and then combine the data in a pairwise fashion until all alignments are merged into one multiple alignment. The easiest way to do so is with help of a guide tree, a clustering of all sequences, which determines in which order sequences are merged with each other. This procedure is illustrated in Fig. 4 for the alignment of four words for 'dog' in four Polynesian languages (Tutorial: 3.2).</p>
<p>Many extensions of the classical guide-tree heuristics have been proposed in the biological literature (Notredame et al., 2000;Morgenstern et al., 1998) and also adapted in linguistic applications (List, 2012a;Ja ¨ger and List, 2015;Hruschka et al., 2015). While the fine-tuning of the algorithms may have a solid impact on multiple alignment analyses involving large sets of language varieties, as we often encounter in dialectology (compare the results of Proki c et al., 2009 with List, 2012a), the problem of erroneous alignments is much less pronounced when using smaller datasets and working in workflows which start from cognate detection and compute multiple alignments in a later stage. For these reasons, we refrain from giving more detailed descriptions of multiple sequence alignment here, but instead refer the readers to the literature that we quoted in this section and the examples in the interactive tutorial (Tutorial: 3.2).</p>
<p>As mentioned in the previous section, we can only meaningfully align words if we know they are historically related. In order to identify which words are related, however, we still need to compare them, and most automatic approaches, including the core methods available in <rs xml:id="12952121" type="software">LingPy</rs>, make use of pairwise sequence comparison techniques in order to find historically related words in linguistic datasets.</p>
<p>The basic workflow of most automatic cognate detection methods can be divided into two major steps. In the first step, pairwise alignment is used to align all words to retrieve distance scores for each pair of words in the data which occur in the same concept slot. If normalized, distance scores typically rank between 0 and 1, with 0 indicating the identity of the objects under comparison, and 1 indicating the maximal difference that can be encountered for the objects. In a second step, these distances are used to partition the words into presumable cognate sets using tree-or network-based partitioning algorithms. If we take five words for 'neck' from our Polynesian data, Ra'ivavae [?agapo?a], Hawaiian [?a:?i:], Mangareva [kaki], Maori [ua], and Rapanui [˛ao], for example, we can use the normalized edit distance (NED) to compare all four words with each other and write the results into a matrix, as shown in Table 5A. 4 In Table 5B, we have carried out the same pairwise comparison, but this time with a different sequence comparison measure, following the sound-class-based alignment method (SCA, List 2012a), in which the idea of sound classes is combined with sequence alignment methods. Table 5C shows the results retrieved from the LexStat method (List, 2012b) which derives distances from a previous search for regular sound correspondences. As can be seen, when comparing only the matrices, the methods generally differ in the way they handle sequence similarities. While NED has rather high scores which do not vary much from each other, SCA has consistently smaller scores with more variation, and LexStat has higher scores but more variation than NED.</p>
<p>In the second step, the matrix of word pair distances is used to partition the words into cognate sets. For this, partitioning algorithms are used which split the words into cognate sets by trying to account as closely as possible for the pairwise distances of all words in a given meaning slot. Early approaches were based on a flat version of the well-known UPGMA algorithm (Sokal and Michener, 1958), which is an agglomerative cluster algorithm that returns the data in the form of a tree. The flat variant of UPGMA stops merging words into bigger subgroups once a user-defined threshold of average pairwise distances among the words in each cluster has been reached (List, 2012b). In order to show how algorithms arrive from pairwise distance scores in a matrix at cognate set partitions, we provide a concrete example in Fig. 5. First, we have marked all cells in which the distance is smaller than the recommended threshold for each method (following List et al., 2017b). 5 Second, we added guide trees (reflecting the clustering proposed when applying the UPGMA algorithm without stopping it earlier) below each matrix, which show how the flat clustering algorithm proceeds. If the algorithm stops grouping words into a given cluster, because the average threshold has been reached, this is indicated by a dashed line, which indicates how the clustering would have proceeded if the algorithm had not stopped. Given that we know that of these five words in the figure, only Hawaiian [?a:?i:] and Mangareva [kaki] are cognate, we can immediately see that the LexStat algorithm is proposing the correct cognates in this example.</p>
<p>The performance of LexStat is not surprising, if we take its more sophisticated working procedure into account. LexStat uses global and local pairwise alignments to pre-analyze the data, computing language-specific scoring functions (List, 2012b), in which the similarity of the segments in a given language pair depends on the overall number of matches that could be found in the preprocessing stage. 6 In these scoring functions, sound segments for all languages in the data are represented as sound-class strings in a certain prosodic environment. This representation is useful to handle sound correspondences in different contexts (word-initial, wordfinal, etc.). For each language pair in the data, LexStat creates an attested and an expected distribution of sound correspondences. The attested distribution is computed for words with the same meaning and whose SCA score is beyond a user-defined threshold. The expected distribution is computed by shuffling the word lists in such a way that words with different meanings are aligned and compared, with the users defining how often word lists should be shuffled. This permutation test following suggestions by Kessler (2001) makes sure that the sound correspondences identified are unlikely to have arisen by chance. The distributions resulting from this permutation test are then combined in log-odds scores (see Fig. 3 above) which can then in turn be used to realign all words and determine their LexStat-distance. 7 These scores are then again used to create a matrix of pairwise distances as shown in Fig. 5. Our interactive tutorial shows how input data can be quickly checked before carrying out the (at times time-consuming) computation (Tutorial: 4.1) and provides additional information regarding the differences between the cognate detection methods available in <rs xml:id="12952122" type="software">LingPy</rs> (Tutorial: 4.2) and illustrates in detail how each of them can be applied (Tutorial: 4.3).</p>
<p>More recent approaches for cognate set partitioning use Infomap (Rosvall and Bergstrom, 2008), a community detection algorithm which uses random walks in a graph representation of the data to identify those clusters in which significantly more edges can be found inside a group than outside (Newman, 2006). In order to model the data as a graph, words are represented as nodes and distances between words are represented as edges which are drawn between all nodes whose pairwise distance is beyond a user-defined threshold (List et al., 2017b). Recent studies have shown that the graph-based partitioning approaches slightly outperform the flat agglomerative clustering procedures (List et al., 2016b(List et al., , 2017b;;Ja ¨ger et al., 2017).</p>
<p>The advantage of LexStat and similar algorithms is that the algorithm infers a lot of information from the data itself. Instead of assuming language-independent distance scores which would be the same for all languages in the world, it essentially infers potential sound correspondences for each language pair in separation and uses this information to determine language-specific distance scores. The disadvantages of LexStat are the computation time and the dependency of data with high mutual coverage. It was designed in such a way that it refuses to cluster words into cognate sets if sufficient information is lacking. As a rule of thumb, derived from earlier studies (List, 2014a), we recommend applying LexStat only if the basic concept lists of a given dataset consists of at least 200 words, and if the mutual coverage of the data exceeds 150 word pairs. If the data is too sparse, such as, for example, in the <rs xml:id="12952123" type="software">ASJP</rs> database <rs xml:id="12952149" type="bibr">(Wichmann et al., 2016)</rs> which gives maximally 40 concepts per language, we recommend to use either the SCA approach, or to turn to more sophisticated machine learning approaches (Ja ¨ger et al., 2017), which have been designed and trained in such a way that they yield their best scores on smaller datasets. In all cases, users should be aware that the algorithms may fail to detect certain cognates. The reasons range from rare sound correspondences which can trigger problematic alignments, via sparseness of data (especially when dealing with divergent languages), up to problems of morphological change which may easily confuse the algorithms as they may yield partial cognates and produce words that cannot be fully aligned anymore (List et al., 2017b). In Table 3, we summarize some basic differences between the four methods mentioned so far.</p>
<p>Once the words have been clustered into cognate sets, it is advisable to align all cognate words with each other, using a multiple alignment algorithm (Tutorial: 4.4). Alignments are useful in multiple ways. First, users can easily inspect them with web-based tools (Tutorial: 4.5). Second, they can be used to statistically investigate the identified sound correspondence patterns in the data (see Tutorial: 4.6). Both the manual and the automatic check of the results provided by automatic cognate detection methods are essential for a successful application of the methods. Only in this way can users either convince themselves that the results come close to their expectations or that something weird is going on. In the latter situation, we recommend that users thoroughly check to which degree they have conformed to our SANE rules for dataset sanity outlined above in Section 3. We also recommend that users do not change the different parameters too much, especially when applying <rs xml:id="12952125" type="software">LingPy</rs> the first time. Instead of trying to fix minor errors (such as obvious cognates missed or lookalikes marked as cognates) by changing parameters, it is often more efficient to correct errors manually. Although Rama et al. (2018) report promising results on fully automated workflows, we do not recommend relying entirely on automatic cognate detection when it comes to phylogenetic reconstruction, since the algorithms tend to be too conservative, often missing valid cognates (List et al., 2017b), but we are confident enough to recommend it for initial data exploration, and for the preparsing of data in order to increase the efficiency of cognate annotation.</p>
<p>We have claimed above that automatic cognate detection had made great progress of late. We make this claim based on tests in which the performance of automatic cognate detection algorithms was compared with expert cognate judgments (List et al., 2017b). There are different ways to compare expert cognate judgments with algorithmic ones. A very simple but nevertheless important one is to compare different cognate judgments manually, by eyeballing the data. Even if one lacks expert cognate judgments for a given dataset, this may be useful, as it helps to get a quick impression on potential weaknesses of the algorithm used for a given analysis. Comparing cognate judgments in concrete, however, can be quite tedious, especially if the data are not presented in any ordered fashion. For this reason, <rs xml:id="12952126" type="software">LingPy</rs> offers a specific format that helps to compare different cognate judgments in a rather convenient way. How this comparison can be carried out is illustrated in Table 4, where we use the numeric annotation for cognate clusters as described in Fig. 6 to compare expert cognate judgments for 'to turn' in eight East Polynesian languages with those produced by edit distance, the SCA, and the LexStat method, respectively. As can be seen from the table, NED lumps all words into one cluster, obviously being confused by the similarity of the vowels across all words. SCA comes close to the expert annotation, but wrongly separates Hawaiian [wili] from the first cluster, obviously being confused by the dissimilarity of the sound classes. LexStat correctly identifies all cognates, obviously thanks to its initial search for language-specific similarities between sound classes. In the interactive tutorial, we show how users can compute similar overviews on differences in cognate detection analyses and conveniently compare them (Tutorial: 5.1).</p>
<p>While manual inspection is important, it is also crucial to have an independent and objective score that tells us how well algorithms perform on a given dataset. Knowing the approximate performance may, for example, be useful when working with large datasets which would take too long to be analyzed manually. If we annotate part of the data and see that the automatic methods perform well enough, we could then use the automatic approaches to carry out our analyses and report the expected accuracy in the study. Our recommended evaluation measures are B-Cubed scores (Bagga and Baldwin, 1998;Amigo ´et al., 2009), which Hauer and Kondrak (2011) first introduced as a measure to assess the quality of cognate detection algorithms compared to expert judgments.</p>
<p>The details of how B-Cubed scores are computed are explained elsewhere in detail (List et al., 2017b), and it would go beyond the scope of this tutorial to introduce them here again. For users interested in automatic cognate detection, but reluctant in learning in depth about evaluation measures in computational linguistics, it is sufficient to know how the B-Cubed scores should be interpreted. Usually the scores are given in three forms, which all rank between 0 and 1: precision, recall, and F-Score. Precision comes closest to the notion of true positives in historical linguistics. Recall is close to the notion of true negatives, accordingly, and the F-Score, the harmonic mean of precision and recall, can be seen as a general summary of the two, derived by the formula , where P is the precision and R is the recall. If the scores are high, this means the algorithms come close to the judgment of the experts, a score of 1.0 in precision and recall (and therefore also the F-Score) means that the results are 100% identical.</p>
<p>In Table 5, we report the results achieved by four automatic cognate detection methods on a small subset of ten East Polynesian languages which we retrieved from our Polynesian dataset for illustrative purposes. 8 In addition to the three methods reported already in Table 4, we added a random cognate detector which was sampled from 100 trials, and the Infomap version of the LexStat algorithm (LS-Infomap), in which the cognate set partitioning is carried out with the Infomap algorithm instead of the flat version of UPGMA (see Section 5 above). 9 NED shows a rather low precision compared to the other nonrandom approaches, indicating that it proposes many false positives (as we could see above in Table 4). On the other hand, its recall is very high, indicating that it does not miss many cognate sets. SCA obviously has a lot of problems with the data, performing worse than NED in general, with a rather low precision and recall. Both LexStat approaches largely outperform the other approaches in general, and especially the very high precision is very comforting, since it indicates that the algorithms do not propose too many false positives. That the Infomap version of LexStat performs better than LexStat with UPGMA is also shown in this comparison, although the differences are much lower than reported in List et al. (2017b). It would be very interesting to compare the scores we achieved with general scores of levels of agreement among human experts. Unfortunately, no systematic study has been carried out so far. 10 The interactive tutorial gives a detailed introduction into the computation of B-Cubed scores with <rs xml:id="12952127" type="software">LingPy</rs> (Tutorial: 5.2). Given the differences in the results regarding precision, recall, and generalized F-scores, it is obvious that the choice of the algorithm to use depends on the task at hand. If users plan to invest much time into manual data correction, having an algorithm with high recall that identifies most of the cognates in the data while proposing a couple of erroneous ones is probably the best choice. Users can achieve this by choosing a high threshold or an algorithm such as NED, which yields a rather high recall in form of the B-Cubed scores, at least for the Polynesian data in our sample. In other cases, however, when usercorrection is not feasible because of the size of the dataset, it is useful to choose low thresholds or generally conservative algorithms with high B-Cubed precision in order to minimize the amount of false positives.</p>
<p><rs xml:id="12952128" type="software">LingPy</rs> provides direct export of the cognate judgments to the Nexus format (Maddison et al., 1997), allowing users to analyze automated cognate judgments with popular packages for phylogenetic reconstruction, such as
<rs xml:id="12952129" type="software">SplitsTree</rs> (Huson, 1998), <rs xml:id="12952130" type="software">MrBayes</rs> <rs xml:id="12952150" type="bibr">(Ronquist et al., 2009)</rs>, or
<rs xml:id="12952132" type="software">BEAST</rs>
<rs xml:id="12952133" type="version" corresp="12952132">2</rs> (<rs xml:id="12952134" type="bibr">Bouckaert et al., 2014</rs>, see Tutorial: 6.1). If phylogenetic trees are computed from distance matrices, both matrices and trees can be written to file and further imported in software packages
for tree manipulation and visualization (Tutorial: 6.2). In addition, data can be exported (and also be imported) to the wordlist format proposed by the CLDF initiative (Forkel et al., 2017), which is intended to serve as a generic format for data sharing in cross-linguistic studies (Tutorial: 6.3).
</p>
<p>In this tutorial we have tried to show how automatic sequence comparison in <rs xml:id="12952135" type="software">LingPy</rs> can be carried out. Given the scope of this article, it is clear that we could not cover all aspects of alignments and cognate detection in all due detail. We hope, however, that we could help readers understand what they should keep in mind if they want to carry out sequence comparison analyses on their own. Additional questions will be answered in an interactive tutorial supplemented with this article, and for deeper questions going beyond the pure application of sequence comparison algorithms-such as additional analyses (e.g. the minimal lateral network method for borrowing detection, List et al., 2014, or an algorithm for the detection of partial cognates, List et al., 2016b), routines for plotting and data visualization, or customization routines for user-defined sound-class modelswe recommend the readers to turn to the extensive online documentation of the <rs xml:id="12952136" type="software">LingPy</rs> package (
<rs xml:id="12952137" type="url" corresp="12952136">http:// lingpy.org</rs>). We have emphasized multiple times throughout this article that the algorithms cannot and should not be used to replace trained linguists. Instead, they should be seen as a useful complement to the large arsenal of methods for historical language comparison which can help experts to derive initial hypotheses on cognacy, speed up tedious annotation of cognate sets, and increase their efficiency and consistency.
</p>
<p>Notes 1. Linguists are often skeptical when they hear that <rs xml:id="12952138" type="software">LingPy</rs> requires explicit phonetic transcriptions, and often, they are even reluctant to interpret their data along the lines of the IPA. But in order to give the algorithms a fair chance to interpret the data in the same way in which they would be interpreted by linguists, a general practice for phonetic transcriptions is indispensable, and the IPA is the most widely employed transcription system. 2. We know well how difficult it is to conform to the latter point. What is clear is that tossing coins to select one out of many synonyms, as originally suggested by Gudschinsky (1956), will have a deleterious impact on any analysis (List, 2018). In order to avoid synonyms in qualitative work, we recommend to thoroughly review the guidelines in Kassian et al. (2010). 3. It would go beyond the scope of this tutorial to explain these famous algorithms in all detail. Instead, we refer the readers to Kondrak (2002: 20-65) as well as to an interactive demo of the Wagner-Fischer algorithm in List (2016). 4. In the normalized edit distance (NED), the edit distance between two strings is further normalized by dividing it by the length of the longer string. In this way, we can control for the length of the compared sequences. 5. The threshold for the algorithms are: NED: 0.75, SCA: 0.45, LexStat: 0.6. 6. For an example, consider the matches between Sikaiana and Tahitian shown in Table 1. Although Sikaiana [k] is different from [?], they are similar from a language-specific perspective, since they recur across many aligned cognate sets between both languages. When comparing [k] in English with [?] in German, however, they are not similar, as we will not find a cognate set in which those two sounds correspond. 7. As alignment algorithms yield similarity scores as a default, the similarity scores are converted to distance scores with help of the formula proposed by Downey et al. (2008). 8. We have not fully explored the practical limitations in terms of number of languages or number of concepts when comparing languages with <rs xml:id="12952139" type="software">LingPy</rs>. Ja ¨ger et al.</p>
<p>(2017) and Rama et al. (2017) report successful applications of <rs xml:id="12952140" type="software">LingPy</rs>'s cognate detection algorithms for as many as 100 languages. Although we think that the number might in fact be even higher, based on tests we carried out ourselves on 150 and more languages, we recommend to be careful when analyzing too many languages, as algorithmic performance may drastically drop when investigation samples are too large 9. The threshold for LexStat-Infomap was set to 0.55, following List et al. (2017b). The random cognate annotation algorithm was designed in such a way that it has the tendency to lump cognates to larger clusters. 10. The only study known to us addressing these problems is Geisler and List (2010), but it has, unfortunately, not been sufficiently quantified.</p>
<p>Figure 6. Some basic concepts important for automatic cognate detection.</p>
<p>140</p>
<p>Journal of Language Evolution, 2018, Vol. 3, No. 2 wnloaded from https://academic.oup.com/jole/article-abstract/3/2/130/5050100 by Music Library, School of Music, National Institute of the Arts, Australian National University user on 10 January 201</p>
<p>Journal of LanguageEvolution, 2018, Vol. 3, No. 2</p>
<p>wnloaded from https://academic.oup.com/jole/article-abstract/3/2/130/5050100 by Music Library, School of Music, National Institute of the Arts, Australian National University user on 10 January 201</p>
<p>We are grateful to three anonymous reviewers for challenging and constructive advice. We thank Russell Gray for encouraging and helpful advice during the preparation of this project, and Christoph Rzymski for helpful comments on an earlier version of this draft.</p>
<p>This research was supported by the European Research Council Starting Grant 'Computer-Assisted Language Comparison' (Grant CALC 715618, J.M.L., T.T.) and the Australian Research Council's Centre of Excellence for the Dynamics of Language (Australian National University, Grant CE140100041, S.J.G.). As part of the GlottoBank project (
http://glottobank.org), this work was further supported by the Department of Linguistic and Cultural Evolution of the Max Planck Institute for the Science of Human History (Jena) and the Royal Society of New Zealand (Marsden Fund, Grant 13-UOA-121).
</p>
<p>Supplementary data is available at Journal of Language Evolution online. Stable updates of this material with the latest version are also available at Zenodo (https://doi.org/10.5281/ zenodo.1252230).</p>
</text>
</tei>